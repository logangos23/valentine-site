<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Valentine?</title>

  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    body {
      margin: 0;
      height: 100vh;
      display: grid;
      place-items: center;
      background: linear-gradient(135deg, #ffe1ea, #fff7fb);
      overflow: hidden;
    }

    .card {
      width: min(520px, calc(100% - 32px));
      background: white;
      border-radius: 20px;
      padding: 28px;
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      text-align: center;
      position: relative;
      z-index: 1;
    }

    h1 { margin: 0 0 20px; font-size: 32px; }

    .buttons {
      display: flex;
      gap: 14px;
      justify-content: center;
      align-items: center;
    }

    button {
      font-size: 18px;
      padding: 12px 20px;
      border-radius: 999px;
      border: 0;
      cursor: pointer;
      transition: transform .08s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    button:active { transform: scale(0.98); }

    #yes, .yesClone { background: #ff4d7d; color: white; }
    #no  { background: #e9e9ef; color: #222; }

    .msg { margin-top: 16px; font-size: 18px; }

    /* Extra Yes buttons spawned around the screen */
    .yesClone {
      position: fixed;
      z-index: 9998;
      box-shadow: 0 10px 25px rgba(0,0,0,.12);
      will-change: transform;
    }
  </style>
</head>

<body>
  <div class="card">
    <h1>Will you be my valentine? üíò</h1>

    <div class="buttons">
      <button id="yes">Yes!</button>
      <button id="no">Noüòî</button>
    </div>

    <div class="msg" id="msg"></div>
  </div>

  <script>
    const yes = document.getElementById("yes");
    const no = document.getElementById("no");
    const msg = document.getElementById("msg");

    // Track mouse position
    const mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    window.addEventListener("mousemove", (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });

    // Utility
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    // NO button flee settings
    const CONFIG = {
      repelRadius: 140,
      maxSpeed: 12,
      accel: 1.1,
      friction: 0.95,
      padding: 16
    };

    // YES swarm settings
    const SWARM = {
      baseSpawn: 22,
      addPerClick: 22,
      maxClones: 220,

      attractRadius: 520,
      accel: 0.35,
      maxSpeed: 8,
      friction: 0.92,
      jitter: 0.05
    };

    // --- NO flee state ---
    let active = false;
    let pos = { x: 0, y: 0 };
    let vel = { x: 0, y: 0 };

    function resetMainButtonsToCenter() {
      // Put NO back into the normal centered layout next to YES
      active = false;
      vel.x = 0; vel.y = 0;
      no.style.display = "";
      no.style.position = "";
      no.style.left = "";
      no.style.top = "";
    }

    function activateFixedPositionOnce() {
      if (active) return;
      active = true;

      const r = no.getBoundingClientRect();
      no.style.position = "fixed";
      no.style.left = `${r.left}px`;
      no.style.top = `${r.top}px`;

      pos.x = r.left;
      pos.y = r.top;
    }

    // Confetti
    function confettiBurst(fromEl) {
      const count = 170;
      const duration = 1400;

      const r = fromEl.getBoundingClientRect();
      const originX = r.left + r.width / 2;
      const originY = r.top + r.height / 2;

      for (let i = 0; i < count; i++) {
        const piece = document.createElement("div");
        piece.style.position = "fixed";
        piece.style.left = originX + "px";
        piece.style.top = originY + "px";
        piece.style.width = (6 + Math.random() * 6) + "px";
        piece.style.height = (8 + Math.random() * 10) + "px";
        piece.style.borderRadius = "2px";
        piece.style.pointerEvents = "none";
        piece.style.zIndex = "9999";
        piece.style.opacity = "1";
        piece.style.background = `hsl(${Math.random() * 360}, 90%, 60%)`;
        document.body.appendChild(piece);

        const angle = Math.random() * Math.PI * 2;
        const power = 220 + Math.random() * 380;

        const dx = Math.cos(angle) * power;
        const dy = Math.sin(angle) * power;

        const gravity = 420 + Math.random() * 260;
        const spin = (Math.random() * 720 - 360);

        piece.animate([
          { transform: "translate(0,0) rotate(0deg)", opacity: 1 },
          { transform: `translate(${dx}px, ${dy + gravity}px) rotate(${spin}deg)`, opacity: 0 }
        ], {
          duration: duration + Math.random() * 600,
          easing: "cubic-bezier(.15,.8,.2,1)",
          fill: "forwards"
        });

        setTimeout(() => piece.remove(), duration + 800);
      }
    }

    // --- YES SWARM DATA ---
    const clones = []; // { el, x, y, vx, vy, w, h }

    function measureClone(c) {
      const r = c.el.getBoundingClientRect();
      c.w = r.width;
      c.h = r.height;
    }

    function removeAllClones() {
      clones.splice(0).forEach(c => c.el.remove());
    }

    function acceptYes(fromEl) {
      confettiBurst(fromEl);

      msg.innerHTML = `
        <div>Yay!! ü•∞üíê</div>

        <div class="letter">
          <strong>Dear Brookie,</strong><br><br>

          I know this might seem over the top or a little much for you when we aren‚Äôt even dating, however, I wanted to do something a little different and special since I‚Äôm not there. I hope you know how much you mean to me and that I cherish what little time we do get to spend together while I am there. I love the dates we go on together and I can‚Äôt stop admiring how gorgeous you look while I‚Äôm there with you. I always have a great time with you and I always look forward to them when I‚Äôm there with you. I hope you have a great weekend a Brookie and I‚Äôll be back out there soon!<br><br>

          <strong>You‚Äôre Valentine,<br>Logi</strong>
        </div>
      `;

      no.style.display = "none";
      active = false;

      removeAllClones();
    }

    yes.addEventListener("click", () => acceptYes(yes));

    // ---- Click NO -> spawn more YES! buttons + RESET main buttons to center ----
    let noClicks = 0;

    function spawnYesSwarm() {
      noClicks += 1;

      const want = SWARM.baseSpawn + noClicks * SWARM.addPerClick;
      const remaining = SWARM.maxClones - clones.length;
      const toSpawn = Math.max(0, Math.min(want, remaining));

      msg.textContent = toSpawn > 0
        ? "NO?! üò≥ Let's try this again..."
        : "You're gonna crash the website! Just please click yes!";

      for (let i = 0; i < toSpawn; i++) {
        const b = document.createElement("button");
        b.textContent = "Yes!";
        b.className = "yesClone";
        document.body.appendChild(b);

        const rect = b.getBoundingClientRect();
        const pad = 12;

        const x = Math.random() * (window.innerWidth - rect.width - pad * 2) + pad;
        const y = Math.random() * (window.innerHeight - rect.height - pad * 2) + pad;

        const c = {
          el: b,
          x, y,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          w: rect.width,
          h: rect.height
        };

        b.style.left = "0px";
        b.style.top = "0px";
        b.style.transform = `translate(${c.x}px, ${c.y}px)`;

        b.addEventListener("click", () => acceptYes(b));
        clones.push(c);
      }
    }

    no.addEventListener("click", () => {
      // Spawn chaos...
      spawnYesSwarm();
      // ...but also reset the main YES/NO back to the centered start layout
      resetMainButtonsToCenter();
    });

    // If the cursor gets near the NO button, "activate" the fleeing behavior
    window.addEventListener("mousemove", () => {
      if (no.style.display === "none") return;

      const r = no.getBoundingClientRect();
      const cx = r.left + r.width / 2;
      const cy = r.top + r.height / 2;
      const d = Math.hypot(mouse.x - cx, mouse.y - cy);

      if (d < CONFIG.repelRadius) activateFixedPositionOnce();
    });

    // Main animation loop
    function tick() {
      // --- NO: run away smoothly ---
      if (active && no.style.display !== "none") {
        const r = no.getBoundingClientRect();
        const cx = pos.x + r.width / 2;
        const cy = pos.y + r.height / 2;

        const dx = cx - mouse.x;
        const dy = cy - mouse.y;
        const dist = Math.hypot(dx, dy) || 0.0001;

        if (dist < CONFIG.repelRadius) {
          const strength = (1 - dist / CONFIG.repelRadius);
          const ax = (dx / dist) * CONFIG.accel * (1 + 2.2 * strength);
          const ay = (dy / dist) * CONFIG.accel * (1 + 2.2 * strength);
          vel.x += ax;
          vel.y += ay;
        }

        vel.x *= CONFIG.friction;
        vel.y *= CONFIG.friction;

        const speed = Math.hypot(vel.x, vel.y);
        if (speed > CONFIG.maxSpeed) {
          vel.x = (vel.x / speed) * CONFIG.maxSpeed;
          vel.y = (vel.y / speed) * CONFIG.maxSpeed;
        }

        pos.x += vel.x;
        pos.y += vel.y;

        const minX = CONFIG.padding;
        const minY = CONFIG.padding;
        const maxX = window.innerWidth - r.width - CONFIG.padding;
        const maxY = window.innerHeight - r.height - CONFIG.padding;

        pos.x = clamp(pos.x, minX, maxX);
        pos.y = clamp(pos.y, minY, maxY);

        no.style.left = `${pos.x}px`;
        no.style.top = `${pos.y}px`;
      }

      // --- YES CLONES: drift toward cursor ---
      if (clones.length) {
        for (const c of clones) {
          const cx = c.x + c.w / 2;
          const cy = c.y + c.h / 2;

          const dx = mouse.x - cx;
          const dy = mouse.y - cy;
          const dist = Math.hypot(dx, dy) || 0.0001;

          const inRange = dist < SWARM.attractRadius;
          const strength = inRange ? (1 - dist / SWARM.attractRadius) : 0.05;

          const ax = (dx / dist) * SWARM.accel * (0.4 + 2.3 * strength);
          const ay = (dy / dist) * SWARM.accel * (0.4 + 2.3 * strength);

          c.vx += ax + (Math.random() - 0.5) * SWARM.jitter;
          c.vy += ay + (Math.random() - 0.5) * SWARM.jitter;

          c.vx *= SWARM.friction;
          c.vy *= SWARM.friction;

          const sp = Math.hypot(c.vx, c.vy);
          if (sp > SWARM.maxSpeed) {
            c.vx = (c.vx / sp) * SWARM.maxSpeed;
            c.vy = (c.vy / sp) * SWARM.maxSpeed;
          }

          c.x += c.vx;
          c.y += c.vy;

          const pad = 10;
          c.x = clamp(c.x, pad, window.innerWidth - c.w - pad);
          c.y = clamp(c.y, pad, window.innerHeight - c.h - pad);

          c.el.style.transform = `translate(${c.x}px, ${c.y}px)`;
        }
      }

      requestAnimationFrame(tick);
    }

    window.addEventListener("resize", () => {
      // If NO is currently fleeing, clamp it
      if (active && no.style.display !== "none") {
        const r = no.getBoundingClientRect();
        pos.x = clamp(pos.x, CONFIG.padding, window.innerWidth - r.width - CONFIG.padding);
        pos.y = clamp(pos.y, CONFIG.padding, window.innerHeight - r.height - CONFIG.padding);
        no.style.left = `${pos.x}px`;
        no.style.top = `${pos.y}px`;
      }

      // Re-measure and clamp clones
      for (const c of clones) {
        measureClone(c);
        c.x = clamp(c.x, 10, window.innerWidth - c.w - 10);
        c.y = clamp(c.y, 10, window.innerHeight - c.h - 10);
        c.el.style.transform = `translate(${c.x}px, ${c.y}px)`;
      }
    });

    tick();
  </script>
</body>
</html>
